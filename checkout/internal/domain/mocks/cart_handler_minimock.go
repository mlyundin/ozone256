package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.CartHandler -o ./mocks/cart_handler_minimock.go -n CartHandlerMock

import (
	"context"
	mm_domain "route256/checkout/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartHandlerMock implements domain.CartHandler
type CartHandlerMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, item *mm_domain.CartItem) (err error)
	inspectFuncAddToCart   func(ctx context.Context, item *mm_domain.CartItem)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCartHandlerMockAddToCart

	funcDeleteFromCart          func(ctx context.Context, item *mm_domain.CartItem) (err error)
	inspectFuncDeleteFromCart   func(ctx context.Context, item *mm_domain.CartItem)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mCartHandlerMockDeleteFromCart

	funcGetItemCount          func(ctx context.Context, userId int64, sku uint32) (u1 uint16, err error)
	inspectFuncGetItemCount   func(ctx context.Context, userId int64, sku uint32)
	afterGetItemCountCounter  uint64
	beforeGetItemCountCounter uint64
	GetItemCountMock          mCartHandlerMockGetItemCount

	funcListCart          func(ctx context.Context, userId int64) (cp1 *mm_domain.Cart, err error)
	inspectFuncListCart   func(ctx context.Context, userId int64)
	afterListCartCounter  uint64
	beforeListCartCounter uint64
	ListCartMock          mCartHandlerMockListCart
}

// NewCartHandlerMock returns a mock for domain.CartHandler
func NewCartHandlerMock(t minimock.Tester) *CartHandlerMock {
	m := &CartHandlerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCartHandlerMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CartHandlerMockAddToCartParams{}

	m.DeleteFromCartMock = mCartHandlerMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*CartHandlerMockDeleteFromCartParams{}

	m.GetItemCountMock = mCartHandlerMockGetItemCount{mock: m}
	m.GetItemCountMock.callArgs = []*CartHandlerMockGetItemCountParams{}

	m.ListCartMock = mCartHandlerMockListCart{mock: m}
	m.ListCartMock.callArgs = []*CartHandlerMockListCartParams{}

	return m
}

type mCartHandlerMockAddToCart struct {
	mock               *CartHandlerMock
	defaultExpectation *CartHandlerMockAddToCartExpectation
	expectations       []*CartHandlerMockAddToCartExpectation

	callArgs []*CartHandlerMockAddToCartParams
	mutex    sync.RWMutex
}

// CartHandlerMockAddToCartExpectation specifies expectation struct of the CartHandler.AddToCart
type CartHandlerMockAddToCartExpectation struct {
	mock    *CartHandlerMock
	params  *CartHandlerMockAddToCartParams
	results *CartHandlerMockAddToCartResults
	Counter uint64
}

// CartHandlerMockAddToCartParams contains parameters of the CartHandler.AddToCart
type CartHandlerMockAddToCartParams struct {
	ctx  context.Context
	item *mm_domain.CartItem
}

// CartHandlerMockAddToCartResults contains results of the CartHandler.AddToCart
type CartHandlerMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CartHandler.AddToCart
func (mmAddToCart *mCartHandlerMockAddToCart) Expect(ctx context.Context, item *mm_domain.CartItem) *mCartHandlerMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartHandlerMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartHandlerMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CartHandlerMockAddToCartParams{ctx, item}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CartHandler.AddToCart
func (mmAddToCart *mCartHandlerMockAddToCart) Inspect(f func(ctx context.Context, item *mm_domain.CartItem)) *mCartHandlerMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CartHandlerMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CartHandler.AddToCart
func (mmAddToCart *mCartHandlerMockAddToCart) Return(err error) *CartHandlerMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartHandlerMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartHandlerMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CartHandlerMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CartHandler.AddToCart method
func (mmAddToCart *mCartHandlerMockAddToCart) Set(f func(ctx context.Context, item *mm_domain.CartItem) (err error)) *CartHandlerMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CartHandler.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CartHandler.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CartHandler.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCartHandlerMockAddToCart) When(ctx context.Context, item *mm_domain.CartItem) *CartHandlerMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartHandlerMock.AddToCart mock is already set by Set")
	}

	expectation := &CartHandlerMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CartHandlerMockAddToCartParams{ctx, item},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CartHandler.AddToCart return parameters for the expectation previously defined by the When method
func (e *CartHandlerMockAddToCartExpectation) Then(err error) *CartHandlerMock {
	e.results = &CartHandlerMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements domain.CartHandler
func (mmAddToCart *CartHandlerMock) AddToCart(ctx context.Context, item *mm_domain.CartItem) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, item)
	}

	mm_params := &CartHandlerMockAddToCartParams{ctx, item}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CartHandlerMockAddToCartParams{ctx, item}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CartHandlerMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CartHandlerMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, item)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CartHandlerMock.AddToCart. %v %v", ctx, item)
	return
}

// AddToCartAfterCounter returns a count of finished CartHandlerMock.AddToCart invocations
func (mmAddToCart *CartHandlerMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CartHandlerMock.AddToCart invocations
func (mmAddToCart *CartHandlerMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CartHandlerMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCartHandlerMockAddToCart) Calls() []*CartHandlerMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CartHandlerMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CartHandlerMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CartHandlerMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartHandlerMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartHandlerMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CartHandlerMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CartHandlerMock.AddToCart")
	}
}

type mCartHandlerMockDeleteFromCart struct {
	mock               *CartHandlerMock
	defaultExpectation *CartHandlerMockDeleteFromCartExpectation
	expectations       []*CartHandlerMockDeleteFromCartExpectation

	callArgs []*CartHandlerMockDeleteFromCartParams
	mutex    sync.RWMutex
}

// CartHandlerMockDeleteFromCartExpectation specifies expectation struct of the CartHandler.DeleteFromCart
type CartHandlerMockDeleteFromCartExpectation struct {
	mock    *CartHandlerMock
	params  *CartHandlerMockDeleteFromCartParams
	results *CartHandlerMockDeleteFromCartResults
	Counter uint64
}

// CartHandlerMockDeleteFromCartParams contains parameters of the CartHandler.DeleteFromCart
type CartHandlerMockDeleteFromCartParams struct {
	ctx  context.Context
	item *mm_domain.CartItem
}

// CartHandlerMockDeleteFromCartResults contains results of the CartHandler.DeleteFromCart
type CartHandlerMockDeleteFromCartResults struct {
	err error
}

// Expect sets up expected params for CartHandler.DeleteFromCart
func (mmDeleteFromCart *mCartHandlerMockDeleteFromCart) Expect(ctx context.Context, item *mm_domain.CartItem) *mCartHandlerMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartHandlerMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartHandlerMockDeleteFromCartExpectation{}
	}

	mmDeleteFromCart.defaultExpectation.params = &CartHandlerMockDeleteFromCartParams{ctx, item}
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the CartHandler.DeleteFromCart
func (mmDeleteFromCart *mCartHandlerMockDeleteFromCart) Inspect(f func(ctx context.Context, item *mm_domain.CartItem)) *mCartHandlerMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for CartHandlerMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by CartHandler.DeleteFromCart
func (mmDeleteFromCart *mCartHandlerMockDeleteFromCart) Return(err error) *CartHandlerMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartHandlerMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartHandlerMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &CartHandlerMockDeleteFromCartResults{err}
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the CartHandler.DeleteFromCart method
func (mmDeleteFromCart *mCartHandlerMockDeleteFromCart) Set(f func(ctx context.Context, item *mm_domain.CartItem) (err error)) *CartHandlerMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the CartHandler.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the CartHandler.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	return mmDeleteFromCart.mock
}

// When sets expectation for the CartHandler.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mCartHandlerMockDeleteFromCart) When(ctx context.Context, item *mm_domain.CartItem) *CartHandlerMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartHandlerMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &CartHandlerMockDeleteFromCartExpectation{
		mock:   mmDeleteFromCart.mock,
		params: &CartHandlerMockDeleteFromCartParams{ctx, item},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up CartHandler.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *CartHandlerMockDeleteFromCartExpectation) Then(err error) *CartHandlerMock {
	e.results = &CartHandlerMockDeleteFromCartResults{err}
	return e.mock
}

// DeleteFromCart implements domain.CartHandler
func (mmDeleteFromCart *CartHandlerMock) DeleteFromCart(ctx context.Context, item *mm_domain.CartItem) (err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, item)
	}

	mm_params := &CartHandlerMockDeleteFromCartParams{ctx, item}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_got := CartHandlerMockDeleteFromCartParams{ctx, item}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("CartHandlerMock.DeleteFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the CartHandlerMock.DeleteFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, item)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to CartHandlerMock.DeleteFromCart. %v %v", ctx, item)
	return
}

// DeleteFromCartAfterCounter returns a count of finished CartHandlerMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartHandlerMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of CartHandlerMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartHandlerMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to CartHandlerMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mCartHandlerMockDeleteFromCart) Calls() []*CartHandlerMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*CartHandlerMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *CartHandlerMock) MinimockDeleteFromCartDone() bool {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *CartHandlerMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartHandlerMock.DeleteFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartHandlerMock.DeleteFromCart")
		} else {
			m.t.Errorf("Expected call to CartHandlerMock.DeleteFromCart with params: %#v", *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		m.t.Error("Expected call to CartHandlerMock.DeleteFromCart")
	}
}

type mCartHandlerMockGetItemCount struct {
	mock               *CartHandlerMock
	defaultExpectation *CartHandlerMockGetItemCountExpectation
	expectations       []*CartHandlerMockGetItemCountExpectation

	callArgs []*CartHandlerMockGetItemCountParams
	mutex    sync.RWMutex
}

// CartHandlerMockGetItemCountExpectation specifies expectation struct of the CartHandler.GetItemCount
type CartHandlerMockGetItemCountExpectation struct {
	mock    *CartHandlerMock
	params  *CartHandlerMockGetItemCountParams
	results *CartHandlerMockGetItemCountResults
	Counter uint64
}

// CartHandlerMockGetItemCountParams contains parameters of the CartHandler.GetItemCount
type CartHandlerMockGetItemCountParams struct {
	ctx    context.Context
	userId int64
	sku    uint32
}

// CartHandlerMockGetItemCountResults contains results of the CartHandler.GetItemCount
type CartHandlerMockGetItemCountResults struct {
	u1  uint16
	err error
}

// Expect sets up expected params for CartHandler.GetItemCount
func (mmGetItemCount *mCartHandlerMockGetItemCount) Expect(ctx context.Context, userId int64, sku uint32) *mCartHandlerMockGetItemCount {
	if mmGetItemCount.mock.funcGetItemCount != nil {
		mmGetItemCount.mock.t.Fatalf("CartHandlerMock.GetItemCount mock is already set by Set")
	}

	if mmGetItemCount.defaultExpectation == nil {
		mmGetItemCount.defaultExpectation = &CartHandlerMockGetItemCountExpectation{}
	}

	mmGetItemCount.defaultExpectation.params = &CartHandlerMockGetItemCountParams{ctx, userId, sku}
	for _, e := range mmGetItemCount.expectations {
		if minimock.Equal(e.params, mmGetItemCount.defaultExpectation.params) {
			mmGetItemCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemCount.defaultExpectation.params)
		}
	}

	return mmGetItemCount
}

// Inspect accepts an inspector function that has same arguments as the CartHandler.GetItemCount
func (mmGetItemCount *mCartHandlerMockGetItemCount) Inspect(f func(ctx context.Context, userId int64, sku uint32)) *mCartHandlerMockGetItemCount {
	if mmGetItemCount.mock.inspectFuncGetItemCount != nil {
		mmGetItemCount.mock.t.Fatalf("Inspect function is already set for CartHandlerMock.GetItemCount")
	}

	mmGetItemCount.mock.inspectFuncGetItemCount = f

	return mmGetItemCount
}

// Return sets up results that will be returned by CartHandler.GetItemCount
func (mmGetItemCount *mCartHandlerMockGetItemCount) Return(u1 uint16, err error) *CartHandlerMock {
	if mmGetItemCount.mock.funcGetItemCount != nil {
		mmGetItemCount.mock.t.Fatalf("CartHandlerMock.GetItemCount mock is already set by Set")
	}

	if mmGetItemCount.defaultExpectation == nil {
		mmGetItemCount.defaultExpectation = &CartHandlerMockGetItemCountExpectation{mock: mmGetItemCount.mock}
	}
	mmGetItemCount.defaultExpectation.results = &CartHandlerMockGetItemCountResults{u1, err}
	return mmGetItemCount.mock
}

// Set uses given function f to mock the CartHandler.GetItemCount method
func (mmGetItemCount *mCartHandlerMockGetItemCount) Set(f func(ctx context.Context, userId int64, sku uint32) (u1 uint16, err error)) *CartHandlerMock {
	if mmGetItemCount.defaultExpectation != nil {
		mmGetItemCount.mock.t.Fatalf("Default expectation is already set for the CartHandler.GetItemCount method")
	}

	if len(mmGetItemCount.expectations) > 0 {
		mmGetItemCount.mock.t.Fatalf("Some expectations are already set for the CartHandler.GetItemCount method")
	}

	mmGetItemCount.mock.funcGetItemCount = f
	return mmGetItemCount.mock
}

// When sets expectation for the CartHandler.GetItemCount which will trigger the result defined by the following
// Then helper
func (mmGetItemCount *mCartHandlerMockGetItemCount) When(ctx context.Context, userId int64, sku uint32) *CartHandlerMockGetItemCountExpectation {
	if mmGetItemCount.mock.funcGetItemCount != nil {
		mmGetItemCount.mock.t.Fatalf("CartHandlerMock.GetItemCount mock is already set by Set")
	}

	expectation := &CartHandlerMockGetItemCountExpectation{
		mock:   mmGetItemCount.mock,
		params: &CartHandlerMockGetItemCountParams{ctx, userId, sku},
	}
	mmGetItemCount.expectations = append(mmGetItemCount.expectations, expectation)
	return expectation
}

// Then sets up CartHandler.GetItemCount return parameters for the expectation previously defined by the When method
func (e *CartHandlerMockGetItemCountExpectation) Then(u1 uint16, err error) *CartHandlerMock {
	e.results = &CartHandlerMockGetItemCountResults{u1, err}
	return e.mock
}

// GetItemCount implements domain.CartHandler
func (mmGetItemCount *CartHandlerMock) GetItemCount(ctx context.Context, userId int64, sku uint32) (u1 uint16, err error) {
	mm_atomic.AddUint64(&mmGetItemCount.beforeGetItemCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemCount.afterGetItemCountCounter, 1)

	if mmGetItemCount.inspectFuncGetItemCount != nil {
		mmGetItemCount.inspectFuncGetItemCount(ctx, userId, sku)
	}

	mm_params := &CartHandlerMockGetItemCountParams{ctx, userId, sku}

	// Record call args
	mmGetItemCount.GetItemCountMock.mutex.Lock()
	mmGetItemCount.GetItemCountMock.callArgs = append(mmGetItemCount.GetItemCountMock.callArgs, mm_params)
	mmGetItemCount.GetItemCountMock.mutex.Unlock()

	for _, e := range mmGetItemCount.GetItemCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetItemCount.GetItemCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemCount.GetItemCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemCount.GetItemCountMock.defaultExpectation.params
		mm_got := CartHandlerMockGetItemCountParams{ctx, userId, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemCount.t.Errorf("CartHandlerMock.GetItemCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemCount.GetItemCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemCount.t.Fatal("No results are set for the CartHandlerMock.GetItemCount")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetItemCount.funcGetItemCount != nil {
		return mmGetItemCount.funcGetItemCount(ctx, userId, sku)
	}
	mmGetItemCount.t.Fatalf("Unexpected call to CartHandlerMock.GetItemCount. %v %v %v", ctx, userId, sku)
	return
}

// GetItemCountAfterCounter returns a count of finished CartHandlerMock.GetItemCount invocations
func (mmGetItemCount *CartHandlerMock) GetItemCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemCount.afterGetItemCountCounter)
}

// GetItemCountBeforeCounter returns a count of CartHandlerMock.GetItemCount invocations
func (mmGetItemCount *CartHandlerMock) GetItemCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemCount.beforeGetItemCountCounter)
}

// Calls returns a list of arguments used in each call to CartHandlerMock.GetItemCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemCount *mCartHandlerMockGetItemCount) Calls() []*CartHandlerMockGetItemCountParams {
	mmGetItemCount.mutex.RLock()

	argCopy := make([]*CartHandlerMockGetItemCountParams, len(mmGetItemCount.callArgs))
	copy(argCopy, mmGetItemCount.callArgs)

	mmGetItemCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemCountDone returns true if the count of the GetItemCount invocations corresponds
// the number of defined expectations
func (m *CartHandlerMock) MinimockGetItemCountDone() bool {
	for _, e := range m.GetItemCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemCount != nil && mm_atomic.LoadUint64(&m.afterGetItemCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetItemCountInspect logs each unmet expectation
func (m *CartHandlerMock) MinimockGetItemCountInspect() {
	for _, e := range m.GetItemCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartHandlerMock.GetItemCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemCountCounter) < 1 {
		if m.GetItemCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartHandlerMock.GetItemCount")
		} else {
			m.t.Errorf("Expected call to CartHandlerMock.GetItemCount with params: %#v", *m.GetItemCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemCount != nil && mm_atomic.LoadUint64(&m.afterGetItemCountCounter) < 1 {
		m.t.Error("Expected call to CartHandlerMock.GetItemCount")
	}
}

type mCartHandlerMockListCart struct {
	mock               *CartHandlerMock
	defaultExpectation *CartHandlerMockListCartExpectation
	expectations       []*CartHandlerMockListCartExpectation

	callArgs []*CartHandlerMockListCartParams
	mutex    sync.RWMutex
}

// CartHandlerMockListCartExpectation specifies expectation struct of the CartHandler.ListCart
type CartHandlerMockListCartExpectation struct {
	mock    *CartHandlerMock
	params  *CartHandlerMockListCartParams
	results *CartHandlerMockListCartResults
	Counter uint64
}

// CartHandlerMockListCartParams contains parameters of the CartHandler.ListCart
type CartHandlerMockListCartParams struct {
	ctx    context.Context
	userId int64
}

// CartHandlerMockListCartResults contains results of the CartHandler.ListCart
type CartHandlerMockListCartResults struct {
	cp1 *mm_domain.Cart
	err error
}

// Expect sets up expected params for CartHandler.ListCart
func (mmListCart *mCartHandlerMockListCart) Expect(ctx context.Context, userId int64) *mCartHandlerMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartHandlerMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CartHandlerMockListCartExpectation{}
	}

	mmListCart.defaultExpectation.params = &CartHandlerMockListCartParams{ctx, userId}
	for _, e := range mmListCart.expectations {
		if minimock.Equal(e.params, mmListCart.defaultExpectation.params) {
			mmListCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCart.defaultExpectation.params)
		}
	}

	return mmListCart
}

// Inspect accepts an inspector function that has same arguments as the CartHandler.ListCart
func (mmListCart *mCartHandlerMockListCart) Inspect(f func(ctx context.Context, userId int64)) *mCartHandlerMockListCart {
	if mmListCart.mock.inspectFuncListCart != nil {
		mmListCart.mock.t.Fatalf("Inspect function is already set for CartHandlerMock.ListCart")
	}

	mmListCart.mock.inspectFuncListCart = f

	return mmListCart
}

// Return sets up results that will be returned by CartHandler.ListCart
func (mmListCart *mCartHandlerMockListCart) Return(cp1 *mm_domain.Cart, err error) *CartHandlerMock {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartHandlerMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CartHandlerMockListCartExpectation{mock: mmListCart.mock}
	}
	mmListCart.defaultExpectation.results = &CartHandlerMockListCartResults{cp1, err}
	return mmListCart.mock
}

// Set uses given function f to mock the CartHandler.ListCart method
func (mmListCart *mCartHandlerMockListCart) Set(f func(ctx context.Context, userId int64) (cp1 *mm_domain.Cart, err error)) *CartHandlerMock {
	if mmListCart.defaultExpectation != nil {
		mmListCart.mock.t.Fatalf("Default expectation is already set for the CartHandler.ListCart method")
	}

	if len(mmListCart.expectations) > 0 {
		mmListCart.mock.t.Fatalf("Some expectations are already set for the CartHandler.ListCart method")
	}

	mmListCart.mock.funcListCart = f
	return mmListCart.mock
}

// When sets expectation for the CartHandler.ListCart which will trigger the result defined by the following
// Then helper
func (mmListCart *mCartHandlerMockListCart) When(ctx context.Context, userId int64) *CartHandlerMockListCartExpectation {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartHandlerMock.ListCart mock is already set by Set")
	}

	expectation := &CartHandlerMockListCartExpectation{
		mock:   mmListCart.mock,
		params: &CartHandlerMockListCartParams{ctx, userId},
	}
	mmListCart.expectations = append(mmListCart.expectations, expectation)
	return expectation
}

// Then sets up CartHandler.ListCart return parameters for the expectation previously defined by the When method
func (e *CartHandlerMockListCartExpectation) Then(cp1 *mm_domain.Cart, err error) *CartHandlerMock {
	e.results = &CartHandlerMockListCartResults{cp1, err}
	return e.mock
}

// ListCart implements domain.CartHandler
func (mmListCart *CartHandlerMock) ListCart(ctx context.Context, userId int64) (cp1 *mm_domain.Cart, err error) {
	mm_atomic.AddUint64(&mmListCart.beforeListCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListCart.afterListCartCounter, 1)

	if mmListCart.inspectFuncListCart != nil {
		mmListCart.inspectFuncListCart(ctx, userId)
	}

	mm_params := &CartHandlerMockListCartParams{ctx, userId}

	// Record call args
	mmListCart.ListCartMock.mutex.Lock()
	mmListCart.ListCartMock.callArgs = append(mmListCart.ListCartMock.callArgs, mm_params)
	mmListCart.ListCartMock.mutex.Unlock()

	for _, e := range mmListCart.ListCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmListCart.ListCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCart.ListCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListCart.ListCartMock.defaultExpectation.params
		mm_got := CartHandlerMockListCartParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCart.t.Errorf("CartHandlerMock.ListCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCart.ListCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListCart.t.Fatal("No results are set for the CartHandlerMock.ListCart")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmListCart.funcListCart != nil {
		return mmListCart.funcListCart(ctx, userId)
	}
	mmListCart.t.Fatalf("Unexpected call to CartHandlerMock.ListCart. %v %v", ctx, userId)
	return
}

// ListCartAfterCounter returns a count of finished CartHandlerMock.ListCart invocations
func (mmListCart *CartHandlerMock) ListCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.afterListCartCounter)
}

// ListCartBeforeCounter returns a count of CartHandlerMock.ListCart invocations
func (mmListCart *CartHandlerMock) ListCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.beforeListCartCounter)
}

// Calls returns a list of arguments used in each call to CartHandlerMock.ListCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCart *mCartHandlerMockListCart) Calls() []*CartHandlerMockListCartParams {
	mmListCart.mutex.RLock()

	argCopy := make([]*CartHandlerMockListCartParams, len(mmListCart.callArgs))
	copy(argCopy, mmListCart.callArgs)

	mmListCart.mutex.RUnlock()

	return argCopy
}

// MinimockListCartDone returns true if the count of the ListCart invocations corresponds
// the number of defined expectations
func (m *CartHandlerMock) MinimockListCartDone() bool {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockListCartInspect logs each unmet expectation
func (m *CartHandlerMock) MinimockListCartInspect() {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartHandlerMock.ListCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		if m.ListCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartHandlerMock.ListCart")
		} else {
			m.t.Errorf("Expected call to CartHandlerMock.ListCart with params: %#v", *m.ListCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		m.t.Error("Expected call to CartHandlerMock.ListCart")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartHandlerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockDeleteFromCartInspect()

		m.MinimockGetItemCountInspect()

		m.MinimockListCartInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockGetItemCountDone() &&
		m.MinimockListCartDone()
}
